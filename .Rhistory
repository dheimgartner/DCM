beta_s <- param["beta_s"]
sigma <- matrix(c(sigma_11, sigma_12, sigma_21, sigma_22), 2, 2)
bsXxs <- beta_s * xs
Phi <- pnorm(-bsXxs)
selection <- (1 - ys) * log(Phi)
yo_boXxo <- yo - beta_o * xo
phi <- sapply(yo_boXxo, function(x) dmvnorm(c(0, x), sigma = sigma)) # this is wrong!
outcome <- ys * log(phi * (1 - Phi))
ll <- sum(selection + outcome)
cat(ll, "\n")
ll
}
p <- function(v) {
assertthat::assert_that(length(v) == 4,
msg = "v has to be a vector of length 4")
setNames(v, c("sigma_12", "sigma_22", "beta_s", "beta_o"))
}
loglik(p(c(0.7, 1, 2, 3)))
nDraws <- 5e3
loglik <- function(param) {
set.seed(0)
bo <- param["beta_o"]
bs <- param["beta_s"]
s11 <- 1
s12 <- param["sigma_12"]
s21 <- s12 # it's a cov matrix!
s22 <- param["sigma_22"]
sigma <- matrix(c(s11, s12, s21, s22), 2, 2)
Phi <- pnorm(-bs * xs, sd = s11) # s11 = 1 -> standard normal CDF
mean_yo_ <- bo * xo
mean_ys_ <- bs * xs
draws <- map2(mean_ys_, mean_yo_, function(s, o) rmvnorm(nDraws, mean = c(s, o), sigma = sigma))
draws_ys <- map(draws, function(x) x[, 1])
indicator <- map(draws_ys, function(x) x > 0)
integral <- unlist(map(indicator, function(x) mean(x)))
flag_0 <- as.numeric(ys == 0)
flag_1 <- 1 - flag_0
log_0 <- log(Phi)
log_1 <- log(integral)
ll <- sum(flag_0 * log_0, flag_1 * log_1)
cat(ll, "\n")
ll
}
loglik(p(c(0.5, 1, 1, 1)))
loglik(p(c(0.9, 1, 4, 1)))
loglik(p(c(0.7, 1, 2, 3)))
m <- maxLik::maxLik(loglik, start = p(c(0.7, 1, 2, 3)))
m
rm(list = ls())
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# library(DCM)
library(tidyverse)
library(mvtnorm)
# Parameters
n <- 1000
gamma <- 1
alpha <- 2
rho <- 0.5
a1 <- 0.5
a2 <- 1.5
ground_truth <- c(gamma = gamma, alpha = alpha, rho = rho, a1 = a1, a2 = a2)
# Errors
set.seed(0)
errors <- rmvnorm(n, c(0, 0), sigma = matrix(c(1, rho, rho, 1), 2, 2))
epsilon <- errors[, 1]
eta <- errors[, 2]
# Data generating process
X <- runif(n)
t_star <- gamma * X + epsilon
t <- t_star > 0
Z <- runif(n)
N_star <- alpha * Z + eta
N <- cut(N_star, breaks = c(-Inf, a1, a2, Inf))
levels(N) <- c(1, 2, 3)
N <- as.numeric(N)
N <- N * t
# Model frame
dat <- data.frame(
X = X,
Z = Z,
t = as.numeric(t),
N = N
)
ground_truth
table(dat$t)
table(dat$N)
head(dat)
lik <- function(param, verbose = FALSE) {
# Unpack params
alpha <- param["alpha"]
gamma <- param["gamma"]
rho <- param["rho"]
a1 <- param["a1"]
a2 <- param["a2"]
# Helpers
M1 <- as.numeric(dat$N == 1)
M2 <- as.numeric(dat$N == 2)
M3 <- as.numeric(dat$N == 3)
gammaX <- gamma * dat$X
alphaZ <- alpha * dat$Z
sigma <- matrix(c(1, rho, rho, 1), 2, 2)
# lik
# likelihood for selection process
selection <- (1 - pnorm(gammaX))**(1 - dat$t)
# j = 1
f <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- 0
j1 <- (f - s)**M1
# j = 2
f <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j2 <- (f - s)**M2
# j = 3
f <- 1
s <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j3 <- (f - s)**M3
# likelihood for observation process
observation <- (j1 * j2 * j3)**dat$t
l <- sum(selection * observation)
if (verbose)
cat(l, "\n")
l
}
lik(param = c(gamma = 2, alpha = 3, rho = 0.7, a1 = -1, a2 = 1))
lik(param = c(gamma = 1, alpha = 1, rho = 0.7, a1 = 0, a2 = 1))
lik(param = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5))
lik(param = ground_truth)
m <- maxLik::maxLik(lik, start = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5), verbose = TRUE)
lik <- function(param, verbose = FALSE) {
cat("param:\t", param, "\n")
# Unpack params
alpha <- param["alpha"]
gamma <- param["gamma"]
rho <- param["rho"]
a1 <- param["a1"]
a2 <- param["a2"]
# Helpers
M1 <- as.numeric(dat$N == 1)
M2 <- as.numeric(dat$N == 2)
M3 <- as.numeric(dat$N == 3)
gammaX <- gamma * dat$X
alphaZ <- alpha * dat$Z
sigma <- matrix(c(1, rho, rho, 1), 2, 2)
# lik
# likelihood for selection process
selection <- (1 - pnorm(gammaX))**(1 - dat$t)
# j = 1
f <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- 0
j1 <- (f - s)**M1
# j = 2
f <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j2 <- (f - s)**M2
# j = 3
f <- 1
s <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j3 <- (f - s)**M3
# likelihood for observation process
observation <- (j1 * j2 * j3)**dat$t
l <- sum(selection * observation)
if (verbose)
cat(l, "\n==============================\n")
l
}
lik(param = c(gamma = 2, alpha = 3, rho = 0.7, a1 = -1, a2 = 1))
lik(param = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5))
lik(param = ground_truth)
m <- maxLik::maxLik(lik, start = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5), verbose = TRUE)
help(package = "maxLik")
ground_truth
m <- maxLik::maxLik(lik, start = c(gamma = 1, alpha = 1, rho = 0.5, a1 = -1, a2 = 1), fixed = "rho", verbose = TRUE)
m <- maxLik::maxLik(lik, start = c(gamma = 1, alpha = 1, rho = 0.5, a1 = -1, a2 = 1), fixed = "rho", verbose = TRUE)
dat$t
T + F
TRUE + FALSE
TRUE & FALSE
Mstar1 <- dat$t & (dat$N == 1)
dat$t & (dat$N == 1)
dat$N[3]
dat
dat$t[3]
?pmvnorm
pbinorm_ <- function(vx, sigma) {
assertthat::assert_that(length(vx) == 2)
pmvnorm(upper = vx, sigma = sigma)
}
pbinorm <- function(vx1, vx2, sigma) {
assertthat::are_equal(length(vx1), length(vx2))
idx <- seq_along(vx1)
out <- sapply(idx, function(x) {
vx <- c(vx1[x], vx2[x])
pbinorm_(vx, sigma = sigma)
})
return(out)
}
alpha <- param["alpha"]
param <- ground_truth
alpha <- param["alpha"]
gamma <- param["gamma"]
rho <- param["rho"]
a1 <- param["a1"]
a2 <- param["a2"]
alphaZ <- alpha * dat$Z
Mstar1 <- dat$t & (dat$N == 1)
Mstar3 <- dat$t & (dat$N == 3)
x1 <- 1 - pnorm(gammaX)
gammaX <- gamma * dat$X
alphaZ <- alpha * dat$Z
Mstar1 <- dat$t & (dat$N == 1)
Mstar2 <- dat$t & (dat$N == 2)
Mstar3 <- dat$t & (dat$N == 3)
x1 <- 1 - pnorm(gammaX)
# x2 where j = 1
x21 <- pbinorm(gammaX, a1 - alphaZ, sigma = sigma)
sigma <- matrix(c(1, rho, rho, 1), 2, 2)
# x2 where j = 1
x21 <- pbinorm(gammaX, a1 - alphaZ, sigma = sigma)
x21
x22 <- pbinorm(gammaX, a2 - alphaZ, sigma = sigma)
x23 <- pbinorm(gammaX, Inf - alphaZ, sigma = sigma)
x23
alphaZ
Inf - alphaZ
pbinrom(upper = inf)
pbinorm
pbinorm()
pmvnorm()
pmvnorm(sigma = 1)
x23 <- pbinorm(gammaX, Inf, sigma = sigma)
x23 <- pbinorm(gammaX, rep(n, Inf), sigma = sigma)
x23 <- pbinorm(gammaX, rep(Inf, n), sigma = sigma)
x23
x23 <- pbinorm(gammaX, Inf, sigma = sigma)
x23 <- pbinorm(gammaX, Inf - alphaZ, sigma = sigma)
x23
x23 <- pbinorm(gammaX, Inf - alphaZ, sigma = sigma)
set.seed(0)
test <- pbinorm(gammaX, rep(Inf, n), sigma = sigma)
test
x23 == test
# x3 where j = 1
x31 <- pbinorm(gammaX, rep(-Inf, n), sigma = sigma)
x32 <- pbinorm(gammaX, a1 - alphaZ, sigma = sigma)
x33 <- pbinorm(gammaX, a2 - alphaZ, sigma = sigma)
Mstar1 * log(x21 - x31)
loglik <- function(param) {
set.seed(0)
alpha <- param["alpha"]
gamma <- param["gamma"]
rho <- param["rho"]
a1 <- param["a1"]
a2 <- param["a2"]
gammaX <- gamma * dat$X
alphaZ <- alpha * dat$Z
sigma <- matrix(c(1, rho, rho, 1), 2, 2)
Mstar1 <- dat$t & (dat$N == 1)
Mstar2 <- dat$t & (dat$N == 2)
Mstar3 <- dat$t & (dat$N == 3)
x1 <- 1 - pnorm(gammaX)
# x2 where j = 1
x21 <- pbinorm(gammaX, a1 - alphaZ, sigma = sigma)
x22 <- pbinorm(gammaX, a2 - alphaZ, sigma = sigma)
x23 <- pbinorm(gammaX, rep(Inf, n), sigma = sigma)
# x3 where j = 1
x31 <- pbinorm(gammaX, rep(-Inf, n), sigma = sigma)
x32 <- pbinorm(gammaX, a1 - alphaZ, sigma = sigma)
x33 <- pbinorm(gammaX, a2 - alphaZ, sigma = sigma)
first_part <- (1 - dat$t) * log(x1)
second_part <- Mstar1 * log(x21 - x31) + Mstar2 * log(x22 - x32) + Mstar3 * log(x23 - x33)
ll <- sum(first_part, second_part)
cat(ll, "\n")
ll
}
loglik(param = c(gamma = 2, alpha = 3, rho = 0.7, a1 = -1, a2 = 1))
loglik(param = c(gamma = 1, alpha = 1, rho = 0.7, a1 = 0, a2 = 1))
loglik(param = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5))
loglik(param = ground_truth)
ground_truth
m <- maxLik::maxLik(loglik, start = c(gamma = 1, alpha = 2, rho = 0.5, a1 = 0.5, a2 = 1.5))
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# library(DCM)
library(tidyverse)
library(mvtnorm)
# Parameters
n <- 1000
gamma <- 1
alpha <- 2
rho <- 0.5
a1 <- 0.5
a2 <- 1.5
ground_truth <- c(gamma = gamma, alpha = alpha, rho = rho, a1 = a1, a2 = a2)
# Errors
set.seed(0)
errors <- rmvnorm(n, c(0, 0), sigma = matrix(c(1, rho, rho, 1), 2, 2))
epsilon <- errors[, 1]
eta <- errors[, 2]
# Data generating process
X <- runif(n)
t_star <- gamma * X + epsilon
t <- t_star > 0
Z <- runif(n)
N_star <- alpha * Z + eta
N <- cut(N_star, breaks = c(-Inf, a1, a2, Inf))
levels(N) <- c(1, 2, 3)
N <- as.numeric(N)
N <- N * t
# Model frame
dat <- data.frame(
X = X,
Z = Z,
t = as.numeric(t),
N = N
)
ground_truth
table(dat$t)
table(dat$N)
head(dat)
lik <- function(param, verbose = FALSE) {
# Unpack params
alpha <- param["alpha"]
gamma <- param["gamma"]
rho <- param["rho"]
a1 <- param["a1"]
a2 <- param["a2"]
# Helpers
M1 <- as.numeric(dat$N == 1)
M2 <- as.numeric(dat$N == 2)
M3 <- as.numeric(dat$N == 3)
gammaX <- gamma * dat$X
alphaZ <- alpha * dat$Z
sigma <- matrix(c(1, rho, rho, 1), 2, 2)
# lik
# likelihood for selection process
selection <- (1 - pnorm(gammaX))**(1 - dat$t)
# j = 1
f <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- unlist(map2(gammaX, rep(-Inf, n), function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j1 <- (f - s)**M1
# j = 2
f <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j2 <- (f - s)**M2
# j = 3
f <- unlist(map2(gammaX, rep(Inf, n), function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j3 <- (f - s)**M3
# likelihood for observation process
observation <- (j1 * j2 * j3)**dat$t
l <- sum(selection * observation)
if (verbose)
cat(l, "\n")
l
}
lik(param = c(gamma = 2, alpha = 3, rho = 0.7, a1 = -1, a2 = 1))
lik(param = c(gamma = 1, alpha = 1, rho = 0.7, a1 = 0, a2 = 1))
lik(param = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5))
lik(param = ground_truth)
debugonce(loglik)
loglik(param = ground_truth)
x21
second_part
x21 - x31
x21 - x31 %>% hist()
hist(x21 - x31)
first_part
second_part
first_part + second_part
second_part
second_part[1:10]
dat$T[1:10]
dat$t[1:10]
mixl::estimate()
mixl::estimate
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# library(DCM)
library(tidyverse)
library(mvtnorm)
# Parameters
n <- 1000
gamma <- 1
alpha <- 2
rho <- 0.5
a1 <- 0.5
a2 <- 1.5
ground_truth <- c(gamma = gamma, alpha = alpha, rho = rho, a1 = a1, a2 = a2)
# Errors
set.seed(0)
errors <- rmvnorm(n, c(0, 0), sigma = matrix(c(1, rho, rho, 1), 2, 2))
epsilon <- errors[, 1]
eta <- errors[, 2]
# Data generating process
X <- runif(n)
t_star <- gamma * X + epsilon
t <- t_star > 0
Z <- runif(n)
N_star <- alpha * Z + eta
N <- cut(N_star, breaks = c(-Inf, a1, a2, Inf))
levels(N) <- c(1, 2, 3)
N <- as.numeric(N)
N <- N * t
# Model frame
dat <- data.frame(
X = X,
Z = Z,
t = as.numeric(t),
N = N
)
ground_truth
table(dat$t)
table(dat$N)
head(dat)
lik <- function(param, verbose = FALSE) {
# Unpack params
alpha <- param["alpha"]
gamma <- param["gamma"]
rho <- param["rho"]
a1 <- param["a1"]
a2 <- param["a2"]
# Helpers
M1 <- as.numeric(dat$N == 1)
M2 <- as.numeric(dat$N == 2)
M3 <- as.numeric(dat$N == 3)
gammaX <- gamma * dat$X
alphaZ <- alpha * dat$Z
sigma <- matrix(c(1, rho, rho, 1), 2, 2)
# lik
# likelihood for selection process
selection <- (1 - pnorm(gammaX))**(1 - dat$t)
# j = 1
f <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- 0 # this is wrong!
j1 <- (f - s)**M1
# j = 2
f <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
s <- unlist(map2(gammaX, a1 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j2 <- (f - s)**M2
# j = 3
f <- 1 # this is also wrong!
s <- unlist(map2(gammaX, a2 - alphaZ, function(a, b) pmvnorm(upper = c(a, b), sigma = sigma)))
j3 <- (f - s)**M3
# likelihood for observation process
observation <- (j1 * j2 * j3)**dat$t
l <- sum(selection * observation)
if (verbose)
cat(l, "\n")
l
}
lik(param = c(gamma = 2, alpha = 3, rho = 0.7, a1 = -1, a2 = 1))
lik(param = c(gamma = 1, alpha = 1, rho = 0.7, a1 = 0, a2 = 1))
lik(param = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5))
lik(param = ground_truth)
pbinorm_ <- function(vx, sigma) {
assertthat::assert_that(length(vx) == 2)
pmvnorm(upper = vx, sigma = sigma)
}
pbinorm <- function(vx1, vx2, sigma) {
assertthat::are_equal(length(vx1), length(vx2))
idx <- seq_along(vx1)
out <- sapply(idx, function(x) {
vx <- c(vx1[x], vx2[x])
pbinorm_(vx, sigma = sigma)
})
return(out)
}
loglik <- function(param) {
set.seed(0)
alpha <- param["alpha"]
gamma <- param["gamma"]
rho <- param["rho"]
a1 <- param["a1"]
a2 <- param["a2"]
gammaX <- gamma * dat$X
alphaZ <- alpha * dat$Z
sigma <- matrix(c(1, rho, rho, 1), 2, 2)
Mstar1 <- dat$t & (dat$N == 1)
Mstar2 <- dat$t & (dat$N == 2)
Mstar3 <- dat$t & (dat$N == 3)
x1 <- 1 - pnorm(gammaX)
# x2 where j = 1
x21 <- pbinorm(gammaX, a1 - alphaZ, sigma = sigma)
x22 <- pbinorm(gammaX, a2 - alphaZ, sigma = sigma)
x23 <- pbinorm(gammaX, rep(Inf, n), sigma = sigma)
# x3 where j = 1
x31 <- pbinorm(gammaX, rep(-Inf, n), sigma = sigma)
x32 <- pbinorm(gammaX, a1 - alphaZ, sigma = sigma)
x33 <- pbinorm(gammaX, a2 - alphaZ, sigma = sigma)
first_part <- (1 - dat$t) * log(x1)
second_part <- Mstar1 * log(x21 - x31) + Mstar2 * log(x22 - x32) + Mstar3 * log(x23 - x33)
ll <- sum(first_part, second_part)
cat(ll, "\n")
ll
}
loglik(param = c(gamma = 2, alpha = 3, rho = 0.7, a1 = -1, a2 = 1))
loglik(param = c(gamma = 1, alpha = 1, rho = 0.7, a1 = 0, a2 = 1))
loglik(param = c(gamma = 1, alpha = 2, rho = 0.7, a1 = 0.5, a2 = 1.5))
loglik(param = ground_truth)
hessian_func <- function(param) numDeriv::hessian(loglik, param)
m <- maxLik::maxLik(loglik,
start = c(gamma = 1, alpha = 2, rho = 0.5, a1 = 0.5, a2 = 1.5),
method = "BFGS",
print.level = 4,
hess = hessian_func)
