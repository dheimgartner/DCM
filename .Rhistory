v
}
param <- c(0, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
# providing gradient and hessian
grad <- function(betas) numDeriv::grad(loglik, betas)
hess <- function(betas) numDeriv::hessian(loglik, betas)
m <- maxLik::maxLik(loglik, start = param, method = "BFGS", grad = grad, hess = hess)
summary(m)
# providing gradient and hessian
grad <- function(betas) numDeriv::grad(loglik, betas)
hess <- function(betas) numDeriv::hessian(loglik, betas)
m <- maxLik::maxLik(loglik, start = param, grad = grad, hess = hess)
devtools::load_all()
rm(list = ls())
sim_dat <- simulate_binary()
beta <- sim_dat$beta
dat <- sim_dat$data
fit <- glm(choice ~ x1 + x2, data = dat, family = binomial(link = "logit"))
summary(fit)
# Closed-form solution ----------------------------------------------------
loglik <- function(param) {
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
exp <- exp(latent)
P_1n <- exp / (1 + exp)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
# Simulation (draws matrix) -----------------------------------------------
n_draws <- 10000
n_rows <- nrow(dat)
draws_matrix <- matrix(rlogis(n_draws * n_rows), nrow = n_rows, ncol = n_draws)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense but...
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
#... param values do not get updated?
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
m
# providing gradient and hessian
grad <- function(betas) numDeriv::grad(loglik, betas)
hess <- function(betas) numDeriv::hessian(loglik, betas)
m <- maxLik::maxLik(loglik, start = param, method = "BFGS", grad = grad, hess = hess)
m
summary(m)
sim_dat <- simulate_binary(n = 10000)
sim_dat <- simulate_binary(n = 10000)
rm(list = ls())
sim_dat <- simulate_binary(n = 10000)
beta <- sim_dat$beta
dat <- sim_dat$data
fit <- glm(choice ~ x1 + x2, data = dat, family = binomial(link = "logit"))
summary(fit)
# Closed-form solution ----------------------------------------------------
loglik <- function(param) {
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
exp <- exp(latent)
P_1n <- exp / (1 + exp)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
# Simulation (draws matrix) -----------------------------------------------
n_draws <- 10000
n_rows <- nrow(dat)
draws_matrix <- matrix(rlogis(n_draws * n_rows), nrow = n_rows, ncol = n_draws)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense but...
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
#... param values do not get updated?
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
m
summary(m)
# Simulation (draws matrix) -----------------------------------------------
n_draws <- 10000
n_rows <- nrow(dat)
draws_matrix <- matrix(rlogis(n_draws * n_rows), nrow = n_rows, ncol = n_draws)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
# P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
# Simulation (draws matrix) -----------------------------------------------
n_draws <- 1000
n_rows <- nrow(dat)
draws_matrix <- matrix(rlogis(n_draws * n_rows), nrow = n_rows, ncol = n_draws)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
# P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
sum(c(-Inf, infert))
sum(c(-Inf, 1, 2, 3))
sum(c(-Inf, Inf, 1, 2, 3))
sum(c(-Inf, Inf, 1, 2, 3), na.rm = TRUE)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
# P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n), na.rm = TRUE)
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
epsilon <- 0.01
pmax(pmin(c(0, 0.1, 1), 1 - epsilon), epsilon)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
# P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
sim_dat <- simulate_binary(beta = c(ASC = 1, beta1 = 2, beta2 = 3), n = 10000)
rm(list = ls())
sim_dat <- simulate_binary(beta = c(ASC = 1, beta1 = 2, beta2 = 3), n = 10000)
beta <- sim_dat$beta
dat <- sim_dat$data
fit <- glm(choice ~ x1 + x2, data = dat, family = binomial(link = "logit"))
summary(fit)
# Closed-form solution ----------------------------------------------------
loglik <- function(param) {
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
exp <- exp(latent)
P_1n <- exp / (1 + exp)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
# Simulation (draws matrix) -----------------------------------------------
n_draws <- 1000
n_rows <- nrow(dat)
draws_matrix <- matrix(rlogis(n_draws * n_rows), nrow = n_rows, ncol = n_draws)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
# P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
loglik <- function(param, epsilon = 1e-10) {
# 1000 x 1
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
# 1000 x n_draws
indicator_ <- latent + draws_matrix
indicator <- (indicator_ > 0)
P_1n <- apply(indicator, 1, mean)
P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
# loglik clearly makes sense
loglik(p(c(0, 0, 0)))
loglik(p(c(1, 1, 1)))
loglik(p(c(1, 2, 3)))
loglik(p(c(0, 1, 2)))
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
loglik(p(c(0, 1, 2)))
summary(m)
debugonce(summary)
summary(m)
result
t
coef(object)
stdEr(object)
stdEr(object, eigentol = eigentol)
debugonce(stdEr)
stdEr(object, eigentol = eigentol)
x
vcov(x, eigentol = eigentol)
if (!is.null(vc <- vcov(x, eigentol = eigentol))) {
s <- sqrt(diag(vc))
names(s) <- names(coef(x))
return(s)
}
debugonce(summary)
summary(m)
stdEr(object, eigentol = eigentol)
stdEr(object, eigentol = eigentol)
debugonce(stdEr)
stdEr(object, eigentol = eigentol)
vc <- vcov(x, eigentol = eigentol)
vc
s <- sqrt(diag(vc))
?vcov
# Simulation (draws internal) ---------------------------------------------
loglik <- function(param) {
n_draws <- 1000
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
set.seed(0)
P_1n_ <- matrix(NA, nrow = nrow(dat), ncol = n_draws)
for (i in seq(n_draws)) {
# take a new random draw for each individual!
error <- rlogis(nrow(dat))
P_1n_[, i] <- as.numeric(latent + error > 0)
}
# average
P_1n <- apply(P_1n_, 1, mean)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
rm(list = ls())
sim_dat <- simulate_binary(n = 10000)
beta <- sim_dat$beta
dat <- sim_dat$data
fit <- glm(choice ~ x1 + x2, data = dat, family = binomial(link = "logit"))
summary(fit)
# Simulation (draws internal) ---------------------------------------------
loglik <- function(param) {
n_draws <- 1000
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
set.seed(0)
P_1n_ <- matrix(NA, nrow = nrow(dat), ncol = n_draws)
for (i in seq(n_draws)) {
# take a new random draw for each individual!
error <- rlogis(nrow(dat))
P_1n_[, i] <- as.numeric(latent + error > 0)
}
# average
P_1n <- apply(P_1n_, 1, mean)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
devtools::load_all()
rm(list = ls())
sim_dat <- simulate_binary(n = 10000)
beta <- sim_dat$beta
dat <- sim_dat$data
fit <- glm(choice ~ x1 + x2, data = dat, family = binomial(link = "logit"))
summary(fit)
# Closed-form solution ----------------------------------------------------
loglik <- function(param) {
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
exp <- exp(latent)
P_1n <- exp / (1 + exp)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
summary(m)
hessian_function <- function(param) numDeriv::hessian(loglik, param)
m <- maxLik::maxLik(loglik, start = param, method = "BFGS", hess = hessian_function)
summary(m)
# Simulation (draws internal) ---------------------------------------------
loglik <- function(param) {
n_draws <- 1000
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
set.seed(0)
P_1n_ <- matrix(NA, nrow = nrow(dat), ncol = n_draws)
for (i in seq(n_draws)) {
# take a new random draw for each individual!
error <- rlogis(nrow(dat))
P_1n_[, i] <- as.numeric(latent + error > 0)
}
# average
P_1n <- apply(P_1n_, 1, mean)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
param <- c(0, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
loglik(param)
debugonce(loglik)
loglik(param)
P_1n
ll
log(P_1n)
log(P_1n) %>% table()
table(log(P_1n))
# Simulation (draws internal) ---------------------------------------------
loglik <- function(param, epsilon = 1e-10) {
n_draws <- 1000
latent <- param["ASC"] + param["beta1"] * dat$x1 + param["beta2"] * dat$x2
set.seed(0)
P_1n_ <- matrix(NA, nrow = nrow(dat), ncol = n_draws)
for (i in seq(n_draws)) {
# take a new random draw for each individual!
error <- rlogis(nrow(dat))
P_1n_[, i] <- as.numeric(latent + error > 0)
}
# average
P_1n <- apply(P_1n_, 1, mean)
P_1n <- pmax(pmin(P_1n, 1 - epsilon), epsilon)
P_0n <- 1 - P_1n
y_1n <- dat$choice
y_0n <- 1 - y_1n
ll <- sum(y_1n * log(P_1n) + y_0n * log(P_0n))
cat(ll, "\n")
ll
}
param <- c(1, 1, 1)
param <- setNames(param, c("ASC", "beta1", "beta2"))
loglik(param)
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
p <- function(v) {
v <- setNames(v, c("ASC", "beta1", "beta2"))
v
}
param <- p(c(1, 1, 1))
loglik(param)
param <- p(c(1, 1, 1))
loglik(param)
loglik(p(c(0, 1, 2)))
m <- maxLik::maxLik(loglik, start = param, method = "BFGS")
